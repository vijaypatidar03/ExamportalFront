{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module watchdog/editorwatchdog\n */\n\n/* globals console */\n\nimport { throttle, cloneDeepWith, isElement } from 'lodash-es';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport Watchdog from './watchdog';\n\n/**\n * A watchdog for CKEditor 5 editors.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n *\n * @extends {module:watchdog/watchdog~Watchdog}\n */\nexport default class EditorWatchdog extends Watchdog {\n  /**\n   * @param {*} Editor The editor class.\n   * @param {module:watchdog/watchdog~WatchdogConfig} [watchdogConfig] The watchdog plugin configuration.\n   */\n  constructor(Editor, watchdogConfig = {}) {\n    super(watchdogConfig);\n\n    /**\n     * The current editor instance.\n     *\n     * @private\n     * @type {module:core/editor/editor~Editor}\n     */\n    this._editor = null;\n\n    /**\n     * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,\n     * unless a new action happens in the meantime.\n     *\n     * @private\n     * @type {Function}\n     */\n    this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);\n\n    /**\n     * The latest saved editor data represented as a root name -> root data object.\n     *\n     * @private\n     * @member {Object.<String,String>} #_data\n     */\n\n    /**\n     * The last document version.\n     *\n     * @private\n     * @member {Number} #_lastDocumentVersion\n     */\n\n    /**\n     * The editor source element or data.\n     *\n     * @private\n     * @member {HTMLElement|String|Object.<String|String>} #_elementOrData\n     */\n\n    /**\n     * The editor configuration.\n     *\n     * @private\n     * @member {Object|undefined} #_config\n     */\n\n    // Set default creator and destructor functions:\n    this._creator = (elementOrData, config) => Editor.create(elementOrData, config);\n    this._destructor = editor => editor.destroy();\n  }\n\n  /**\n   * The current editor instance.\n   *\n   * @readonly\n   * @type {module:core/editor/editor~Editor}\n   */\n  get editor() {\n    return this._editor;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get _item() {\n    return this._editor;\n  }\n\n  /**\n   * Sets the function that is responsible for the editor creation.\n   * It expects a function that should return a promise.\n   *\n   *\t\twatchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );\n   *\n   * @method #setCreator\n   * @param {Function} creator\n   */\n\n  /**\n   * Sets the function that is responsible for the editor destruction.\n   * Overrides the default destruction function, which destroys only the editor instance.\n   * It expects a function that should return a promise or `undefined`.\n   *\n   *\t\twatchdog.setDestructor( editor => {\n   *\t\t\t// Do something before the editor is destroyed.\n   *\n   *\t\t\treturn editor\n   *\t\t\t\t.destroy()\n   *\t\t\t\t.then( () => {\n   *\t\t\t\t\t// Do something after the editor is destroyed.\n   *\t\t\t\t} );\n   *\t\t} );\n   *\n   * @method #setDestructor\n   * @param {Function} destructor\n   */\n\n  /**\n   * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes\n   * the state to `initializing`.\n   *\n   * @protected\n   * @fires restart\n   * @returns {Promise}\n   */\n  _restart() {\n    return Promise.resolve().then(() => {\n      this.state = 'initializing';\n      this._fire('stateChange');\n      return this._destroy();\n    }).catch(err => {\n      console.error('An error happened during the editor destroying.', err);\n    }).then(() => {\n      if (typeof this._elementOrData === 'string') {\n        return this.create(this._data, this._config, this._config.context);\n      } else {\n        const updatedConfig = Object.assign({}, this._config, {\n          initialData: this._data\n        });\n        return this.create(this._elementOrData, updatedConfig, updatedConfig.context);\n      }\n    }).then(() => {\n      this._fire('restart');\n    });\n  }\n\n  /**\n   * Creates the editor instance and keeps it running, using the defined creator and destructor.\n   *\n   * @param {HTMLElement|String|Object.<String|String>} [elementOrData] The editor source element or the editor data.\n   * @param {module:core/editor/editorconfig~EditorConfig} [config] The editor configuration.\n   * @param {Object} [context] A context for the editor.\n   *\n   * @returns {Promise}\n   */\n  create(elementOrData = this._elementOrData, config = this._config, context) {\n    return Promise.resolve().then(() => {\n      super._startErrorHandling();\n      this._elementOrData = elementOrData;\n\n      // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,\n      // when an error occurs in one of these editors, the watchdog will restart all of them.\n      this._config = this._cloneEditorConfiguration(config) || {};\n      this._config.context = context;\n      return this._creator(elementOrData, this._config);\n    }).then(editor => {\n      this._editor = editor;\n      editor.model.document.on('change:data', this._throttledSave);\n      this._lastDocumentVersion = editor.model.document.version;\n      this._data = this._getData();\n      this.state = 'ready';\n      this._fire('stateChange');\n    });\n  }\n\n  /**\n   * Destroys the watchdog and the current editor instance. It fires the callback\n   * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.\n   * It also sets the state to `destroyed`.\n   *\n   * @returns {Promise}\n   */\n  destroy() {\n    return Promise.resolve().then(() => {\n      this.state = 'destroyed';\n      this._fire('stateChange');\n      super.destroy();\n      return this._destroy();\n    });\n  }\n\n  /**\n   * @private\n   * @returns {Promise}\n   */\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n\n      // Save data if there is a remaining editor data change.\n      this._throttledSave.flush();\n      const editor = this._editor;\n      this._editor = null;\n      return this._destructor(editor);\n    });\n  }\n\n  /**\n   * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at\n   * the moment of the crash.\n   *\n   * @private\n   */\n  _save() {\n    const version = this._editor.model.document.version;\n\n    // Operation may not result in a model change, so the document's version can be the same.\n    if (version === this._lastDocumentVersion) {\n      return;\n    }\n    try {\n      this._data = this._getData();\n      this._lastDocumentVersion = version;\n    } catch (err) {\n      console.error(err, 'An error happened during restoring editor data. ' + 'Editor will be restored from the previously saved data.');\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Set} props\n   */\n  _setExcludedProperties(props) {\n    this._excludedProps = props;\n  }\n\n  /**\n   * Returns the editor data.\n   *\n   * @private\n   * @returns {Object<String,String>}\n   */\n  _getData() {\n    const data = {};\n    for (const rootName of this._editor.model.document.getRootNames()) {\n      data[rootName] = this._editor.data.get({\n        rootName\n      });\n    }\n    return data;\n  }\n\n  /**\n   * Traverses the error context and the current editor to find out whether these structures are connected\n   * to each other via properties.\n   *\n   * @protected\n   * @param {module:utils/ckeditorerror~CKEditorError} error\n   */\n  _isErrorComingFromThisItem(error) {\n    return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);\n  }\n\n  /**\n   * Clones the editor configuration.\n   *\n   * @private\n   * @param {Object} config\n   */\n  _cloneEditorConfiguration(config) {\n    return cloneDeepWith(config, (value, key) => {\n      // Leave DOM references.\n      if (isElement(value)) {\n        return value;\n      }\n      if (key === 'context') {\n        return value;\n      }\n    });\n  }\n\n  /**\n   * Fired after the watchdog restarts the error in case of a crash.\n   *\n   * @event restart\n   */\n}","map":null,"metadata":{},"sourceType":"module"}